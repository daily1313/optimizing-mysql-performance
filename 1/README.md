
<details>
<summary> 1장. MYSQL 아키텍쳐 </summary>
MYSQL의 논리적 아키텍처

- 연결 관리 및 보안
- 최적화 및 실행

### 동시성 제어

- 읽기/쓰기 잠금
- 잠금 세분화

### 트랜잭션

- 격리 수준
- 교착
- 트랜잭션 로깅
- MySQL에서의 트랜잭션

### 다중 버전 동시성 제어

### 복제

### 데이터 파일 구조

### InnoDB 엔진

- JSON 문서 지원
- 데이터 딕셔너리의 변화 
- Atomic DDL

</details>

MySQL 논리적 아키텍처

- 최상위 계층인 클라이언트에서는 MySQL의 고유한 서비스보다는 네트워크 기반 클라이언트/서버 도구 또는 서버에 필요한 연결처리, 인증, 보안 등의 서비스 포함
- 두 번째 계층에서는 쿼리 파싱, 분석, 최적화 및 모든 기본 제공함수를 포함하여 MySQL에서 대부분의 지능적인 부분이 여기에 속함
- 세 번째 계층에서는 스토리지 엔진이 포함, MySQL에 저장된 모든 데이터를 저장하고 검색하는 역할 담당
  - 서버는 스토리지 엔진 API를 통해 통신
  - 스토리지 엔진은 SQL을 구문 분석하거나 서로 통신하지 않으며, 단순히 서버의 요청에 응답만 함(외래키 정의 구문 분석은 제외)


연결 관리 및 보안
- 기본적으로 각 클라이언트 연결은 서버 프로세스 내에서 고유한 스레드를 가짐
- 연결 쿼리는 하나의 코어 또는 CPU에 존재하는 단일 스레드 내에서 실행 -> 서버는즉시 사용할 수 있는 스레드의 캐시를 유지 관리하므로, 새로운 연결마다 매번 스레드를 생성하거나 필요가 없음
- 클라이언트가 MySQL 서버에 연결되면 서버에서 인증 (인증은 사용자 이름, 호스트 및 암호를 기반으로 함)
  - X.509 인증서는 TLS 연결에서도 사용할 수 있으며 클라이언트가 연결되면 서버는 클라이언트에서 보내는 각 쿼리에 대해 권한이 있는지 파악

최적화 및 실행
- MySQL은 쿼리를 구문 분석하여 내부 구조(분석 트리)를 생성한 다음, 다양한 최적화 적용
- 쿼리 재작성, 테이블을 읽는 순서 결정, 사용할 인덱스 선택 등이 포함될 수 있습니다.
- 쿼리의 특수 키워드를 통해 옵티마이저에 힌트를 전달하여 의사 결정 프로세스에 영향을 줄 수 있습니다. 
- 옵티마이저는 특정 테이블이 어떤 스토리지 엔진을 사용하는 사용하는지는 관심없지만, 스토리지 엔진은 서버가 쿼리를 최적화하는 방법에 영향을 미칩니다. 옵티마이저는 스토리지 엔진에게 테이블 데이터에 대한 통계뿐만 아니라 일부 기능과 특정 작업의 비용에 대해 묻습니다.

동시성 제어
- 두 개 이상의 쿼리가 동시에 데이터를 변경해야 할 때마다 동시성 제어 문제가 발생
- 스프레드시트 파일을 예시로 들면, 해당 파일에 관하여 여러 사람이 파일을 바꾸게 된다면, 어떻게 될까?
  - 교대로 변경할 수도 있지만, 그다지 효율적이지 못하기에 대용량 스프레드시트에 대한 동시 액세스를 허용하는 접근 방식이 필요

읽기/쓰기 잠금
- 스프레드시트에서 읽는 것은 어렵지 않습니다. 여러 클라이언트가 같은 파일을 동시에 읽는 것은 문제가 되지 않습니다.
- 다른 사람이 스프레드시트를 읽는 동안 A25 셀을 삭제하게 되면, 경우에 따라 다르지만 읽는 도중에 손상된 데이터나 일관되지 않은 뷰를 볼 수 있게 됩니다.
- 동시성 문제의 고질적인 문제에 대한 해결책 : 공유 잠금(Shared Lock, 읽기 잠금), 전용 잠금(Exclusive Lock, 쓰기 잠금)
  - 공유 잠금: 읽기 허용, 쓰기 비허용
  - 쓰기 잠금: 읽기 비허용, 쓰기 비허용
- 유일하게 안전한 정책은 특정 시간에 하나의 클라이언트만 리소스에 쓰고, 클라이언트가 쓸 때는 모든 읽기를 막는 것입니다.

잠금 세분화 
- 공유 리소스의 동시성을 개선하는 방법은 "잠금 항목을 더 선택적으로 설정하는 것"
  - 전체 리소스를 잠그는 대신 변경할 데이터가 포함된 부분만 잠금 ~= 변경하려는 데이터 부분만 잠금
- 잠금은 무료가 아니며 리소스를 소비하기에 잠금 작업업에는 오버헤드가 있습니다
- 시스템이 데이터를 저장하고 검색하는 대신 잠금 관리에 너무 많은 시간을 소비하면 성능 저하
- 잠금 전략은 잠금 오버헤드와 데이터 안전 사이의 tradeoff 
  - 상용 데이터베이스 서버는 선택의 폭이 좁습니다.
  - 테이블에 행 수준 잠금이라고 하는 것을 여러번 사용하여 우수한 성능을 제공하는 다양하고 복잡한 방법 이용 가능
- MySQL은 선택권을 제공합니다. 스토리지 엔진은 자체 잠금 정책과 세분화된 잠금 단위를 구현할 수 있기에 특정 레벨에서 세분화할 때, 특정 용도에서는 성능이 향상되지만 다른 용도에서는 적합하지 않을 수 있습니다.
- 테이블 잠금 / 행 잠금
- 테이블 잠금
  - 가장 기본적인 잠금 전략이자 가장 낮은 오버헤드를 가집니다.
  - 전체 테이블을 잠그고, 클라이언트가 테이블에 쓰기를 원할 때 쓰기 잠금을 획득합니다. 이렇게 하면 다른 모든 읽기 및 쓰기 작업이 차단됩니다.
- 행 잠금
  - 가장 큰 동시성을 제공하고, 오버헤드가 가장 큰 잠금 형태는 행 잠금입니다.
  - 이 방법을 사용하면 여러 명의 사용자가 서로 방해하지 않고 동시에 다른 행을 편집할 수 있습니다.
  - 서버가 더 많은 동시쓰기를 수행할 수 있지만, 잠금에 대한 비용이 큽니다.
  - 행 잠금은 서버가 아닌 스토리지 엔진에서 구현

트랜잭션
- 세분화된 단일 작업 단위로 처리되는 SQL 문의 그룹
- 데이터베이스 엔진이 전체 명령문 그룹을 데이터베이스에 적용할 수 있으면 그렇게 하지만, 충돌이나 다른 이유로 인해 하나라도 수행할 수 없는 경우에는 아예 적용되지 않습니다.

    ```aidl
    STRAT TRANSACTION;
    SELECT balance FROM checking WHERE customer_id = 10233276;
    UPDATE checking SET balance = balance - 200.00 WHERE customer_id = 10233276;
    UPDATE savings SET balance = balance + 200.00 WHERE customer_id = 10233276;
    COMMIT;
    ```
- STRAT TRANSACTION 문으로 트랜잭션을 시작한 다음, COMMIT으로 변경 사항을 영구적으로 적용하거나 ROLLBACK으로 변경사항을 취소


